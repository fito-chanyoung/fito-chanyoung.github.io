---
title: "자바스크립트 톺아보기-2"
toc: true
toc_sticky: true

categories:
  - javascript

last_modified_at: 2020-06-8T13:01:00+00:00
---

이번에는 자바스크립트에 대해 알아본것들을 마저정리해 보고자 한다.
그렇지만 어느정도의 컴퓨터 공학적인 이야기도 다루고 있다.

## 변수 선언, 초기화, 할당

변수는 무엇일까?

변수는 어떤 상황의 가변적 요인을 의미하는 한자이다.

**수학**에서 한자는 정해지지 않은 임의의 값을 표현하는 문자이며
**프로그래밍**에서 변수는 알려지지 않거나 어느정도까지만 알려진 정보를
저장하는 상징적 이름를 가진 메모리 공간이다.

쉽게 이야기 하자면 어떤 선반의 특정 저장장소(메모리)에 'A'라는 이름(변수이름)을 붙여
해당 저장공간에 원하는 데이터를 저장하고 불러와 사용하는것이다.

### 변수 선언

프로그래밍에서 변수를 선언하기위해서는 프로그래밍 언어에 따라 다르지만
보통 다음과 같다.

```js
// 일반적인 경우
(키워드) 변수이름
```

> 파이썬이라는 언어는 키워드를 사용하지 않고 변수에 값을 할당해야 하는듯하다.
> 변수 이름만 선언할수 있는지는 불분명하다.

자바스크립트도 위와 마찬가지로 키워드와 변수이름을 명시해야 한다.
`var/const/let array;`와 같은 형태를 사용하여 변수이름을 명시한다.

자바스크립트를 기준으로 해당 세가지 키워들은 약간의 차이점이 존재한다.

---

1. var
   var 키워드는 직전 포스트에서 다룬것처럼 함수 스코프를 가진다.
   또한 재선언이 가능하며, 변수의 내용을 변경할 수 있다.

이때문에 프로그래밍을 작성할때 var 키워드는 인식하지 못한 버그를
유발할 수 있다.

개인적으로는 let 키워드를 사용하기를 추천한다.

---

2. let
   let 키워드는 블럭스코프를 가진다. 따라서 매칭되는 중괄호를 기준으로
   접근 여부가 나눠진다. 대체로 외부에서는 내부의 함수에 접근이 불가능하다.

다만 **클로져**를 사용한다면 외부에서 내부 함수에 접근이 가능해진다.
var 키워드와 마찬가지로 변수의 내용을 변경할 수 있지만
재선언이 불가능하다. 에러가 발생한다.

---

3. const 키워드
   const 키워드는 간단하다
   재선언이 불가능하고 변수의 내용 변경또한 불가능하다.
   어떤 변수가 변경되어서는 안될경우 사용한다.

const 키워드로 선언한 변수의 재선언 및 변수의 변경이 감지되면
에러가 발생한다.

---

### 변수 초기화

변수를 선언한 이후 변수의 공간을 살펴보면 아무 의미가 없거나
쓸모없는 정보가 담겨있을수 있다.

마치 이사를 해야할때 이사할 집을 청소하는것처럼 해당 변수를 정리해야
한다.

정리하는 방법중 하나는 변수를 선언할때 값을 저장해 버리는
변수 초기화 과정이다.

변수 초기화 과정을 프로그래밍 언어에 따라 반드시 필요할수도, 그렇지 않을
수도 있다.

C계열, 자바 언어는 반드시 초기화 과정을 거쳐야 한다.
자바스크립트는 변수의 초기화 과정이 반드시 필요하지 않다.
변수를 선언하면 처음에는 알수 없는 쓰레기값, undefined로 값이 초기화되어 있다.

```js
// 자바스크립트
let val1 = 10;
// C계열 및 자바
int val2 = 10;
```

### null vs undefined

자바스크립트에서 변수를 선언만 하는 경우 undefined로 초기화 되어 있다고
작성했었다.

그런데, undefined와 비슷한 것이 하나더 존재한다.
null이라는 녀석은 undefined와 그 성격이 유사하다.

우선 null과 undefined의 공통적인 특성은

1. 상수, 스트링등과 값을 비교하면 항상 거짓이다.
2. null 혹은 undefined와 비교하면 참이다.
3. 의미없는 값이 저장되어 있다는 의미이다.
4. 조건문에서 거짓의 값으로 판단된다.

![null in console](/assets/images/null.png);

하지만 엄격한 비교(===)로 비교하면 false인 둘은
차이점이 존재한다.

1. null은 인위적으로 값을 할당해야 한다.
2. undefined는 변수에 자동으로 할당될수 있다.
3. null에 값을 할당할 수 없다. 하지만 undefined에 값을 할당할 수 있다.

### 변수 할당

초기화 이후 변수에 값을 저장하는것을 변수 할당이라고 말한다.

```js
let val1;
val = 50;
```

이때 특정 언어에서 타입을 구분한다면, 저장된 타입과 저장하려는 타입의
차이로인해 에러가 발생할 수도 있다.

## 원시 자료형, 참조 자료형

원시 자료형과 참조 자료형은 메모리 어디에 데이터가 저장되는가?
에 차이로 해석하면 쉽다.

원시 자료형, 영어로 primitive data type인 변수들은
자바스크립트에서 넘버, 스트링, 불리언등등이 해당된다.

이런 타입의 변수들은 저장된 메모리 주소를 찾아가면 그 값을
확인할 수 있다.

하지만 참조 자료형, 영어로 reference data type인 변수들은
객체, 배열이 해당된다.

둘은 메모리 주소를 찾아가면 배열의 값이 아니라 다른 메모리 주소가
나타난다.

그 주소를 다시 찾아가면 배열의 시작 인덱스나 객체의 프로퍼티의 값을
알수 있다.

즉 둘의 차이점은 한번에 값을 알수 있는가 아니면 한번이상 메모리를 탐색
해야 값을 알수 있는가의 차이이다.

### 콜스택과 힙

자바스크립트를 기준으로 한다.

콜스택은 실행중인 프로그램 내부에서 동작하는 함수의 변수 및 리턴 어드레스를
저장하고 있는 스택이다.

프로그래밍을 해본적이 있다면 이해하기 쉬울것이다.
for문이나 함수 내부에서 함수를 실행하는경우
for문 혹은 실행된 함수가 종료되어야만 기존의 함수가 마저 실행된다.

이때 사용되는것이 콜스택이다.
콜스택의 동작방식은 아래를 참고하자.

1. 어떠한 함수 A가 실행중일때 B 함수를 실행해야 한다.
2. 작업을 중지하고 미처 종료하지 못한 함수 A를 나중에 마저 실행하기 위해
   지금까지 작업중이던 함수를 재개하기 위한 리턴어드레스를 콜스택에 밀어 넣는다.
3. B함수를 실행한다. 지역변수, 파라미터등등이 저장된다.
4. 함수 B가 종료된다. B 관련 변수가 콜스택에서 제거된다.
5. 리턴어드레스를 참고하여 작업이 중지된 A함수의 작업내용을 다시 제개한다.
6. A 함수가 종료되면 관련 지역변수, 파라마터등을 콜스택에서 제거한다.

이런 특성상 함수의 호출마다 콜스택에 변수, 파라미터등등이 전부 쌓이기 때문에
재귀적 용법을 사용하는경우 주의를 해야 한다.

---

힙(Heap)은 레퍼런스 타입의 데이터 저장을 위한 메모리 공간이다.
콜스택처럼 특정 구조를 가지고 있지 않다. 데이터를 저장할때 필요한 규칙같은것도
존재하지 않는다.

객체, 배열과 같은 오브젝트들은 힙에 저장이 된다.
사실 콜스택에 저장되기는 한다. 하지만 위에서 말했던 것처럼
주소를 따라가다보면 힙 영역의 메모리 주소를 발견하는것 뿐이다.

### deep copy & swallow copy

변수를 복사하다보면 아래와 같은 경우가 발생한다.

```js
let array1 = [1, 2, 3];
let array2 = array1;

array2[0] = "a";
console.log(array1); // 'a', 2, 3
```

분명 다른 변수에 할당된 배열의 내용을 수정했지만, 원본 배열의 내용까지 영향을 받았다.
이런 복사의 유형을 얕은 복사, swallow copy라고 한다.

얕은 복사는 메모리 주소를 따라가 처음에 발견되는 값을 복사해 오는것이다.
그렇기 때문에 스트링, 넘버, 불리언같은 원시형 데이터 타입의 경우 메모리 주소가 아닌
그 값 자체를 복사하여 저장한다.

하지만 참조형 데이터 타입은 발견되는것이 Heap에 저장된 메모리 주소이기 때문에,
해당 메모리 주소를 복사하여 저장하게 된다. 이것이 위와 같은 현상이 발생하는 이유이다.
(결국 따라가다보면 같은 메모리 주소에 접근한다는 의미)

이런 얕은 복사와 반대되는 개념이 깊은 복사(deep copy)이다.
깊은 복사는 이런 객체, 배열의 메모리주소를 탐색하여 그 값을 복사해야 한다.

즉 위와 같은 현상을 방지하기 위해서는 아래와 같은 과정이 필요하다.

![image](/assets/images/deepcopy.png);

### 호이스팅

자바스크립트에서는 변수는 사용된 이후에 선언될 수도 있다.
바꿔 말하자면 변수는 선언되기 전에 사용할수 있다는 의미.

```js
x = 5; // Assign 5 to x

elem = document.getElementById("demo"); // Find an element
elem.innerHTML = x; // Display x in the element

var x; // Declare x
//출처 https://www.w3schools.com/js/js_hoisting.asp

catName("Chloe"); // My cat's name is Chloe

function catName(name) {
  console.log("My cat's name is " + name);
}
// 출처 https://developer.mozilla.org/ko/docs/Glossary/Hoisting
```

보이는 것처럼 선언이 나중에 이뤄졌지만 x에 값이 할당되었고, 함수가 호출되었다.
이런형식이 호이스팅이라 하며, var 키워드와 함수 선언식의 경우만 사용 가능하다.

두가지 방식의 공통점이 재선언이 가능하다는 것이다. 개인적인 생각으로는 재선언이
가능하다면 호이스팅이 가능하지 않을까 생각된다.

let, const 키워드는 TBZ(Temporal Dead Zone)이라 부르는 호출 불가능한 영역이
변수 선언 직전까지의 영역이다. 따라서 let, const변수는 호이스팅이 불가능하다.

또한 익명 함수를 변수에 저장하는 방식인 함수 표현 방식은 변수가 var로 선언되어 있더
라도 호이스팅이 불가능하다.

```js
catName("Chloe"); //

var catName= function(name) {
  console.log("My cat's name is " + name);
}

-> Uncaught TypeError: catName is not a function
    at <anonymous>:1:1
```

## 가비지 컬렉터

가비지 컬렉터는 메모리상에서 메모리 자원 관리를 위해 필요없다고 판단되는 메모리의
할당을 해제하는 역할을 담당한다.

특이한 점은 프로그래머가 관리하는것이 아니다.
C나 C++은 malloc, new를 사용해서 원하는 만큼 메모리를 할당했었다.
하지만 프로그래머가 free, delete를 사용해서 사용한 메모리를 반드시 해제해
줘야 했는데, 그렇지 않다면 해당 메모리는 아무도 접근하지 않기때문에 사용 가능한
메모리가 부족해지는 메모리 누수가 발생하기 때문이다.

하지만 인간은 늘 실수를 하기 마련이다. 모든 메모리 할당을 프로그래머가
전부 해제하지 않는 경우는 언제나 존재했다.

이런 상황을 막고자 자동으로 할당된 메모리를 해체해주는 가비지 컬렉터가 등장하게 되었다.

가비지 컬렉터는 메모리 할당을 추적하고 더이상 할당된 메모리가 필요없다고 판단되는
경우, 메모리 할당을 해제하고 자원을 반환하는 역할을 담당한다.

이런 **더이상 필요없다고 판단되는 메모리**는 그 대상을 판단하는데 어려움이 있었고
아래와 같은 알고리즘을 통해 가비지 콜렉션을 진행할 메모리를 탐색한다.

### Reference-counting 알고리즘

이 알고리즘은 어떤 오브젝트도 참조하지 않는 메모리를 더이상 필요없는 메모리 할당이라
간주한다.

하지만 메모리 A, B가 서로를 참조하는 경우와 있다면 가비지 콜렉션이 동작하지 않는다.

### Mark-and-sweep 알고리즘

닿을수 없는 메모리 할당일 경우 필요없는 메모리 할당이라 간주하는 알고리즘이다.

현재 브라우저들의 가비지 컬렉션 방법이다.
